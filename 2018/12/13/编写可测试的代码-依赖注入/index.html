<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>编写可测试的代码-依赖注入 · Walking in Pixels</title><meta name="description" content="在代码中，类与类、类与方法或者其他软件实体之间总是存在着某些依赖关系。例如，假设某个类\(A\)的对象\(a\)需要完成某个功能，然而，它需要通过与类\(B\)的对象\(b\)的协作才能够完成该功能。在这个过程中，类\(B\)则成为类\(A\)的一个依赖。类\(B\)的对象\(b\)则成为了一个se"><meta name="og:description" content="在代码中，类与类、类与方法或者其他软件实体之间总是存在着某些依赖关系。例如，假设某个类\(A\)的对象\(a\)需要完成某个功能，然而，它需要通过与类\(B\)的对象\(b\)的协作才能够完成该功能。在这个过程中，类\(B\)则成为类\(A\)的一个依赖。类\(B\)的对象\(b\)则成为了一个se"><meta name="twitter:site" content="Walking in Pixels"><meta name="twitter:title" content="编写可测试的代码-依赖注入"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo injector head_end start --><style>.typst-app {
  margin: 0;
}
</style>
<script>/// https://segmentfault.com/a/1190000016574288
(function () {
  var ie = !!(window.attachEvent && !window.opera);
  var wk = /webkit\/(\d+)/i.test(navigator.userAgent) && RegExp.$1 < 525;
  var fn = [];
  var run = function () {
    for (var i = 0; i < fn.length; i++) fn[i]();
  };
  var d = document;
  d.ready = function (f) {
    if (!ie && !wk && d.addEventListener) return d.addEventListener('DOMContentLoaded', f, false);
    if (fn.push(f) > 1) return;
    if (ie)
      (function () {
        try {
          d.documentElement.doScroll('left');
          run();
        } catch (err) {
          setTimeout(arguments.callee, 0);
        }
      })();
    else if (wk)
      var t = setInterval(function () {
        if (/^(loaded|complete)$/.test(d.readyState)) clearInterval(t), run();
      }, 0);
  };
})();

document.ready(() => {
  let fromCtrlC = false;
  let fromRightClick = false;
  document.addEventListener(
    'keydown',
    evt => (fromCtrlC = evt.key.toUpperCase() == 'C' && evt.ctrlKey),
  );
  document.addEventListener('contextmenu', evt => (fromRightClick = true));
  document.addEventListener('copy', evt => {
    const originatorEvent = fromCtrlC ? 'CTRL-C' : fromRightClick ? 'right click' : 'toolbar menu';
    console.log(`Copy event received from ${originatorEvent} within element`, evt.target);
    fromCtrlC = false;
    fromRightClick = false;

    // evt.clipboardData.setData('text/plain', 'foo');
    // evt.preventDefault(); // default behaviour is to copy any selected text
  });
});
</script>
<script type="module" src="/typst/typst-main.js"></script><script src="/typst/svg-utils.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Lights and Shadows</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">魔泡树的光与影</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="http://example.com/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">Leptus He</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>编写可测试的代码-依赖注入</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2018-12-13</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/Unit-Test/" title="Unit Test">Unit Test</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/Unit-Test/" title="Unit Test">Unit Test</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>在代码中，类与类、类与方法或者其他软件实体之间总是存在着某些依赖关系。例如，假设某个类<span
class="math inline">\(A\)</span>的对象<span
class="math inline">\(a\)</span>需要完成某个功能，然而，它需要通过与类<span
class="math inline">\(B\)</span>的对象<span
class="math inline">\(b\)</span>的协作才能够完成该功能。在这个过程中，类<span
class="math inline">\(B\)</span>则成为类<span
class="math inline">\(A\)</span>的一个依赖。类<span
class="math inline">\(B\)</span>的对象<span
class="math inline">\(b\)</span>则成为了一个service对象（服务的提供者），类<span
class="math inline">\(A\)</span>的对象<span
class="math inline">\(a\)</span>则是一个client对象（服务的使用者）。</p>
<p>在编写代码时，如果类<span class="math inline">\(A\)</span>对类<span
class="math inline">\(B\)</span>存在依赖，即类<span
class="math inline">\(A\)</span>完成某个功能需要类<span
class="math inline">\(B\)</span>提供的某项服务。那么，我们就需要思考一个问题—我们该如何获得一个提供类<span
class="math inline">\(A\)</span>所需要的服务的对象呢？</p>
<h1 id="依赖注入">依赖注入</h1>
<hr />
<p>在一般情况下，类<span
class="math inline">\(A\)</span>可能会自己创建一个能够提供其所需要的服务的对象，即new出一个提供服务的对象。然而，这种方式存在着一些问题。如果类<span
class="math inline">\(A\)</span>的代码中采用了new一个提供服务的对象的方式来获得一个service对象，那么这些代码就是存在耦合的，它违背了面向对象编程中的开闭原则(open/closed
principle)。因为，如果存在其他能够提供相同服务的类<span
class="math inline">\(C\)</span>对象，并且类<span
class="math inline">\(A\)</span>想要使用类<span
class="math inline">\(C\)</span>对象来作为service对象，那么我们就需要修改类<span
class="math inline">\(A\)</span>的代码。这时，代码就不再满足”对扩展是开放的，对修改是关闭的“这两个特征了。</p>
<p>在进行单元测试时，被测试类为了完成某个功能可能需要与其他对象进行协作，例如通过文件系统读取文件或者通过数据库系统获取数据。然而，为了保证单元测试的独立性和可重复性，我们一般都会使用mock对象来替代被测试类所依赖的对象，即service对象。通过这种方式，单元测试的正确性只有被测试类有关，而与被依赖的对象无关。因为如果测试结果依赖于某个外部依赖，例如数据库系统，那么每次的测试结果都可能由于数据库的状态不一样从而导致测试结果不一样，这样就无法保证测试的可重复性和独立性了。</p>
<p>然而，如果被测试类的client代码中存在直接通过new的方式获得service对象的代码，由于service对象无法被替换，那么通过mock对象替换被依赖对象的方法就无法使用了，从而会导致了我们无法写出具有独立性和可重复性的单元测试。我们称这段client代码为不可测试的代码。</p>
<p>为了解决上述所讲的client对象和service对象的耦合问题，我们可以使用一种称为<strong>依赖注入（dependency
injection）</strong>的技术。依赖注入是一种将client对象所依赖的service对象注入到client对象中的技术。通过依赖注入技术，client代码中就不再需要直接通过new的方式来获得service对象了，而是通过由其他代码将service对象注入到client对象中的方式来获得service对象，这就解决了client对象和service对象的耦合问题。在面向对象设计中，这样的代码也是满足了开闭原则的，具有可扩展性。在单元测试中，mock对象就能够通过注入的方式来替换实际的service对象，这样也能够保证我们写出的测试具有独立性和可重复性。这样的代码也称为可测试的代码。</p>
<h1 id="依赖注入的方式">依赖注入的方式</h1>
<hr />
<p>一般而言，将依赖注入的方式具有两种：</p>
<ul>
<li>constructor注入</li>
<li>setter注入</li>
</ul>
<p>以下以一个简单的例子来介绍这两种注入方式：</p>
<p>假设存在一个ModelManager，该类负责从磁盘加载一个model文件并创建出一个Model类对象，然而因为Model类对象是由多个&lt;mesh,
material&gt;对构成的，所以ModelManager无法直接创建Mesh类对象和Material类对象，所以其需要其他对象来创建Mesh类对象和Material类对象，MeshManager类负责从磁盘加载一个mesh文件并创建一个Mesh对象，MaterialManager类负责从磁盘加载一个material文件并创建一个material对象。所以，ModelManager需要MeshManager与MaterialManager的协助才能够完成该功能，即MeshManager和MaterialManager是ModelManager的两个依赖。</p>
<p>以下以这个例子来进行两种注入方式的说明：</p>
<h2 id="constructor注入">Constructor注入</h2>
<pre><code>class ModelManager &#123;
public:
    ModelManager(MeshManager *meshManager, MaterialManager *materialManager)
        : mMeshManager(meshManager), mMaterialManager(materialManager)
    &#123;
        if (!meshManager) &#123;
            throw std::exception(&quot;mesh mananger must not be null&quot;);
        &#125;

        if (!materialManager) &#123;
            throw std::exception(&quot;material manager must not be null&quot;);
        &#125;
    &#125;

    Model loadModel(const std::string&amp; filePath) &#123;
        // load model by mMeshManager and mMaterialManager
    &#125;

private:
    MeshManager *mMeshManager;
    MaterialManager *mMaterialManager;
&#125;</code></pre>
<p>Constructor注入方法是通过将service对象作为constructor的参数来将依赖注入到client类中的。因此，注入的依赖成为了client的状态的一部分。一般而言，如果依赖能够在调用constructor前构造出来，constructor注入方法是首选的依赖注入方法。因为在constructor被调用后，client对象所需要的依赖都已经被满足了，所以constructor注入方法能够保证client对象总是处于一个合法的状态。</p>
<p>Constructor注入的缺点在于缺乏灵活性。当client对象被构造后，它的依赖，即service对象就无法被更改了。在某些情况下，当client对象被构造后，client对象所依赖的service对象可能需要被修改。此时，constructor注入就无法解决这个问题。</p>
<h2 id="setter注入">Setter注入</h2>
<pre><code>class ModelManager &#123;
public:
    ModelManager() : mMeshManager(nullptr), mMaterialManager(nullptr) &#123;&#125;

    void setMeshManager(MeshManager *meshManager) &#123; mMeshManager = meshManager;  &#125;
    void setMaterialManager(MaterialManager *materialManager) &#123; mMaterialManager = materialManager; &#125;

    Model loadModel(const std::string&amp; filePath) &#123;
        validateState();
        // load model by mMeshManager and mMaterialManager
    &#125;

private:
    bool validateState() const &#123;
        if (!meshManager) &#123;
            throw std::exception(&quot;mesh mananger must not be null&quot;);
        &#125;
        if (!materialManager) &#123;
            throw std::exception(&quot;material manager must not be null&quot;);
        &#125;
    &#125;

private:
    MeshManager *mMeshManager;
    MaterialManager *mMaterialManager;
&#125;</code></pre>
<p>Setter注入方法主要是通过提供一个setter函数来注入依赖。它的优点在于能够灵活地注入service对象。在任意时刻，client对象所依赖的service对象都能够被更改。然而，由于service对象的注入时间不确定，从而导致在需要使用service对象时，client对象都需要查看service对象是否已经被注入。当需要使用service对象，而其未被注入时，client对象就处于不合法的状态，导致我们需要编写额外的代码来对这种情况进行处理，从而增加了代码量和其他负担。</p>
<h2
id="constructor注入和setter注入的结合">Constructor注入和Setter注入的结合</h2>
<pre><code>class ModelManager &#123;
public:
    ModelManager(MeshManager *meshManager, MaterialManager *materialManager)
        : mMeshManager(meshManager), mMaterialManager(materialManager)
    &#123;
        if (!meshManager) &#123;
            throw std::exception(&quot;mesh mananger must not be null&quot;);
        &#125;

        if (!materialManager) &#123;
            throw std::exception(&quot;material manager must not be null&quot;);
        &#125;
    &#125;

    void setMeshManager(MeshManager *meshManager) &#123;
        assert(meshManager != nullptr);
        mMeshManager = meshManager;
    &#125;

     void seaMaterialManager(MaterialManager *materialManager) &#123;
        assert(mMaterialManager != nullptr);
        mMaterialManager = materialManager;
     &#125;

    Model loadModel(const std::string&amp; filePath) &#123;
        // load model by mMeshManager and mMaterialManager
    &#125;

private:
    MeshManager *mMeshManager;
    MaterialManager *mMaterialManager;
&#125;</code></pre>
<p>通过结合constructor注入和setter注入方法，我们能够同时拥有两种注入方法的优点，并没有了两种注入方式的缺点。如上所示，在client对象被构造后，其处于一个合法的状态。并且，通过setter函数能够随时替换service对象并保持client对象状态的合法性。</p>
<p>通过两种注入方式的结合，在使用service对象时，我们总能够确保service对象时存在的，从而不用进行验证查找service对象是否存在，进而避免了需要编写异常处理代码的需要。</p>
<h1 id="references">References</h1>
<hr />
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency
injection[wiki]</a></li>
<li><a
target="_blank" rel="noopener" href="https://agostini.tech/2017/03/27/using-dependency-injection/">Using
Dependency Injection[Dejan Agostini][2017]</a></li>
<li><a
target="_blank" rel="noopener" href="https://agostini.tech/2017/04/24/unit-tests-with-dependency-injection/">Unit
Tests with Dependency Injection[Dejan Agostini][2017]</a></li>
</ol>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=http://example.com/2018/12/13/编写可测试的代码-依赖注入/%20Walking in Pixels%20编写可测试的代码-依赖注入"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/03/09/temporal-antialiasing-01/" title="Temporal Antialiasing - 01"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Temporal Antialiasing - 01</a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2024&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">Leptus He</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>