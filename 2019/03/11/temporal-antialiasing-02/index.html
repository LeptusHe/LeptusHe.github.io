<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Temporal Antialiasing - 02 · Walking in Pixels</title><meta name="description" content="# History Color失效的情况
当物体运动或者相机运动时，我们需要通过reprojection操作来获得某个pixel在前一帧中的屏幕空间位置，然后从该位置获取history
color。然而，并不是在任何情况下，history color都是正确的。
相机/物体运动导致的history
"><meta name="og:description" content="# History Color失效的情况
当物体运动或者相机运动时，我们需要通过reprojection操作来获得某个pixel在前一帧中的屏幕空间位置，然后从该位置获取history
color。然而，并不是在任何情况下，history color都是正确的。
相机/物体运动导致的history
"><meta name="twitter:site" content="Walking in Pixels"><meta name="twitter:title" content="Temporal Antialiasing - 02"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style-dark.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo injector head_end start --><style>.typst-app {
  margin: 0;
}
</style>
<script>/// https://segmentfault.com/a/1190000016574288
(function () {
  var ie = !!(window.attachEvent && !window.opera);
  var wk = /webkit\/(\d+)/i.test(navigator.userAgent) && RegExp.$1 < 525;
  var fn = [];
  var run = function () {
    for (var i = 0; i < fn.length; i++) fn[i]();
  };
  var d = document;
  d.ready = function (f) {
    if (!ie && !wk && d.addEventListener) return d.addEventListener('DOMContentLoaded', f, false);
    if (fn.push(f) > 1) return;
    if (ie)
      (function () {
        try {
          d.documentElement.doScroll('left');
          run();
        } catch (err) {
          setTimeout(arguments.callee, 0);
        }
      })();
    else if (wk)
      var t = setInterval(function () {
        if (/^(loaded|complete)$/.test(d.readyState)) clearInterval(t), run();
      }, 0);
  };
})();

document.ready(() => {
  let fromCtrlC = false;
  let fromRightClick = false;
  document.addEventListener(
    'keydown',
    evt => (fromCtrlC = evt.key.toUpperCase() == 'C' && evt.ctrlKey),
  );
  document.addEventListener('contextmenu', evt => (fromRightClick = true));
  document.addEventListener('copy', evt => {
    const originatorEvent = fromCtrlC ? 'CTRL-C' : fromRightClick ? 'right click' : 'toolbar menu';
    console.log(`Copy event received from ${originatorEvent} within element`, evt.target);
    fromCtrlC = false;
    fromRightClick = false;

    // evt.clipboardData.setData('text/plain', 'foo');
    // evt.preventDefault(); // default behaviour is to copy any selected text
  });
});
</script>
<script type="module" src="/typst/typst-main.js"></script><script src="/typst/svg-utils.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Lights and Shadows</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">魔泡树的光与影</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li class="soc"><a href="http://example.com/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">Leptus He</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Temporal Antialiasing - 02</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-03-11</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/Graphics/" title="Graphics">Graphics</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/Graphics/" title="Graphics">Graphics</a><span>&nbsp;</span><a class="a-tag" href="/tags/Antialiasing/" title="Antialiasing">Antialiasing</a><span>&nbsp;</span></span></p><p class="post-abstract"><h2 id="history-color失效的情况"># History Color失效的情况</h2>
<p>当物体运动或者相机运动时，我们需要通过reprojection操作来获得某个pixel在前一帧中的屏幕空间位置，然后从该位置获取history
color。然而，并不是在任何情况下，history color都是正确的。</p>
<h3 id="相机物体运动导致的history-color失效">相机/物体运动导致的history
color失效</h3>
<p>如图1所示，当相机在场景中运动时，当前帧中，某个pixel对应的场景采样点为红色点，为了得到该采样点的history
color，我们使用上一帧的MVP矩阵来将
该红色采样点投影到屏幕空间中后，然而，history
buffer中该屏幕空间位置中存储的history color为绿色采样点的history
color，然而我们需要的是红色采样点的history
color，从而导致我们获得了一个invalid的history color。</p>
<img src="/image/occlusion-history-color.bmp" class="" width="500" height="500" title="图1-被遮挡的fragment">
<p>上述情况产生的根本原因在于某些fragment在当前帧可见，然而在上一帧不可见。导致该情况的原因可能是相机的运动或者物体的运动。例如，当相机运动速度较快时，屏幕边缘处的fragment就会在上一帧中不可见，从而导致history
buffer中没有存储这些fragment的history color。</p>
<h3 id="shading导致的history-color失效">Shading导致的history
color失效</h3>
<p>当物体或者相机运动时，可能会导致当前帧中的某个fragment的history
color没有被存储在history buffer中，从而导致获得的history
color是无效的。</p>
<p>然而，即使我们能够在history buffer中获取到某个fragment对应的history
color，该history
color依然可能无效。假设在上一帧中某个fragment被一个红色的光源照亮，然而在当前帧中该光源颜色变为绿色，从而会导致该fragment的颜色由于shading的变化而不同。最终导致，上一帧的history
color不可用，即history color无效。</p>
<p>导致shading的变化原因有很多，例如： -
光照环境的改变(光源颜色变化、光源开关等) - 阴影的变化（是否处于阴影中）
- 半透明物体的影响</p>
<p>任何会对导致pixel的颜色产生变化的因素都可能会导致history
color变得无效。</p>
<h1 id="history-color失效后的处理">History Color失效后的处理</h1>
<table style="width:6%;">
<colgroup>
<col style="width: 5%" />
</colgroup>
<tbody>
<tr class="odd">
<td>当history
color失效后，我们需要对这种情况进行相应的处理。一种处理方法是丢弃history
color，然后直接使用当前帧的颜色作为最终的颜色。然而，该方法会导致pixel失去反走样效果。</td>
</tr>
<tr class="even">
<td>另一种处理方式是使用neighborhood
clamping方法来进行处理。该方法的基本思想是通过当前帧pixel的一个邻域范围内的像素，来在颜色空间中构造一个颜色范围，然后将history
color的大小限制在该范围之中。该方法的基本的假设是——某个pixel反走样后的颜色基本与该pixel邻域范围内pixel颜色的blending结果相同。如果该假设成立，则将history
color限制在邻域pixel构成的颜色范围中是一种正确的做法。然而，当pixel中存在sub-pixel
feature时，该假设无法成立。</td>
</tr>
<tr class="odd">
<td>Neighborhood
Clamping方法中首先需要根据pixel的邻域颜色来构建一个颜色空间范围，如果我们使用凸包来构造一个颜色空间范围，则我们可以获得一个最小的颜色空间范围。然而，该方法过于复杂，容易造成效率问题。</td>
</tr>
<tr class="even">
<td>另一种构造颜色范围的方法是使用axis-aligned bounding
box(AABB)。通过使用pixel的邻域颜色来构建一个AABB，则可以构造出一个较紧的颜色范围。并且，我们可以将pixel的颜色从RGB颜色空间转换到YCoCg空间后，再在YCoCg颜色空间构造一个AABB。这是因为YCoCg颜色空间能够体现颜色的亮度差异。</td>
</tr>
<tr class="odd">
<td>当history color不在AABB范围中时，一种处理方式是将history
color进行clamping，即</td>
</tr>
<tr class="even">
<td>historyColor = clamp(historyColor, minColor, maxColor);</td>
</tr>
<tr class="odd">
<td>另一种处理方式是使用cliping操作，即计算pixel和history
color所连接形成的线段与AABB的交点。相比较于clamping操作而言，cliping得到的颜色是pixel和history
color的一个插值，与pixel的颜色更相似。</td>
</tr>
<tr class="even">
<td># Flicking问题</td>
</tr>
</tbody>
</table>
<p>在使用neighborhood
clamp方法后，场景中可能会有pixel的闪烁问题。即使当相机与物体静止，pixel的闪烁问题依然可能存在。导致闪烁发生的主要原因在于，场景中存在sub-pixel
feature，从而导致neighborhood
clamp方法的基本假设无法成立。举一个例子来对该情况进行说明。</p>
<img src="/image/flicking.bmp" class="" width="500" height="500" title="图2-flicking">
<p>如图所示，previous frame的pixel的颜色为红色<span
class="math inline">\((1,0,0)\)</span>，并且其邻域颜色构成的AABB中的<span
class="math inline">\(minColor = (1,0,0)\)</span>，<span
class="math inline">\(maxColor=(1,1,1)\)</span>。假设previous
frame的历史颜色为红色<span
class="math inline">\((1,0,0)\)</span>，则经过neighborhood
clamp操作处理后，history color依然为红色，则最终的结果为红色<span
class="math inline">\((1,0,0)\)</span>。在current
frame时，由于sample的变化，导致当前的pixel颜色变为白色<span
class="math inline">\((1,1,1)\)</span>，并且邻域颜色构成的AABB中的<span
class="math inline">\(minColor=(1,1,1)\)</span>，<span
class="math inline">\(maxColor=(1,1,1)\)</span>，经过neighborhood
clamp操作处理后history color变为白色<span
class="math inline">\((1,1,1)\)</span>，则最终经过blending后的颜色为白色<span
class="math inline">\((1,1,1)\)</span>。通过上面简单的例子可以看出，当场景中存在sub-pixel
feature时，即使在静态场景下，像素颜色也会存在帧间变化从而导致闪烁问题的发生。</p>
<h1 id="模糊问题">模糊问题</h1>
<hr />
<p>Temporal
Antialiasing算法存在的另一个问题是模糊问题。当使用了TAA算法后，渲染出来的图片可能会存在一些模糊。导致该问题的原因主要有以下三个：</p>
<ul>
<li>使用了错误的mipmap level</li>
<li>reprojection diffusion</li>
<li>对无效的history color进行blending</li>
</ul>
<p>由于mipmap level与图片的分辨率有关，且temporal
antialiasing算法在每一帧中采样pixel中的一个sample，从而导致在计算mipmap
level时使用的分辨率是屏幕的分辨率。然而，由于temporal
antialiasing算法与super sampling算法类似，实际上在计算mipmap
level时应该使用super
sampling的分辨率，从而导致mipmap的level计算错误。Mipmal
level的计算错误可以通过对计算得到的mipmap level增加一个bias来解决。</p>
<p>Reprojection diffusion问题的产生是由于对history
buffer进行重采样从而导致的。在对history
buffer进行重采样时，采样的位置可能并不在history
buffer中的像素中心位置，从而导致采样得到的颜色是对history
buffer重构的结果，即是插值出来。该插值出来的像素由于不是一个正确的像素颜色，而是插值出来的，则该插值出来的history
color则带有一些模糊的效果，从而会导致blending了该history
color的pixel具有模糊效果。并且，由于history
buffer是不断累积的，会更加剧这个问题。解决该问题的一个方法是使用更好的重构方法来代替线性插值方法，来使得插值出来的pixel更加锐利。例如，使用Catmull-Rom插值方法来进行插值。</p>
<p>与混合了插值出来的history color类似的原因。当history
color无效时，最终的pixel由于混合了无效的history
color，也会导致blending后的pixel带有模糊的效果。</p>
<p>另外，为了减轻TAA导致的模糊问题，我们可以通过为当前帧得到的颜色纹理增加一个sharepen
filter来减轻该问题。</p>
<h1 id="references">References</h1>
<hr />
<ol type="1">
<li>[High-Quality Temporal Super Sampling<a
target="_blank" rel="noopener" href="http://advances.realtimerendering.com/s2014/">Siggraph
2014]</a></li>
<li>[Temporal Super Sampling and Antialiasing<a
target="_blank" rel="noopener" href="https://bartwronski.com/2014/03/15/temporal-supersampling-and-antialiasing/">2014]</a></li>
<li>[Temporal Reprojection Anti-Aliasing in INSIDE<a
target="_blank" rel="noopener" href="http://twvideo01.ubm-us.net/o1/vault/gdc2016/Presentations/Pedersen_LasseJonFuglsang_TemporalReprojectionAntiAliasing.pdf">GDC][2016]</a></li>
<li>[An Excursion in Temporal Super Sampling<a
target="_blank" rel="noopener" href="https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf">GDC][2016]</a></li>
<li>[Amortized Super Sampling<a
target="_blank" rel="noopener" href="http://hhoppe.com/supersample.pdf">Siggraph Asia 2009]</a></li>
</ol>
</p></div><div class="share"><span>공유하기</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=http://example.com/2019/03/11/temporal-antialiasing-02/%20Walking in Pixels%20Temporal Antialiasing - 02"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2023/07/04/spherical-harmonics-01-function-fitting/" title="球谐函数 - 01 Function Fitting"><i class="fa fa-angle-double-left"></i>&nbsp;이전 포스트: 球谐函数 - 01 Function Fitting</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/03/09/temporal-antialiasing-01/" title="Temporal Antialiasing - 01">다음 포스트: Temporal Antialiasing - 01&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://example.com" rel="noopener noreferrer">Leptus He</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>